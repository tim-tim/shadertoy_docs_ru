# 01. Рисуем круг

Начнем со стартового шаблона Shadertoy и внесем следующие изменения:

- добавим переменные для определения цвета переднего плана и фона: `fg_color` и `bg_color` соотвественно;
- создадим переменную `radius` для хранения желаемого радиуса нашего круга;
- воспользовавшись уравнением Пифагора, вычислим и сохраним в переменную `dist` расстояние от начала координат нашего "холста" до текущего, обрабатываемого в шейдере фрагмента(пикселя);
- на основе сравнения полученного расстояния с желаемым радиусом выбираем в какой цвет (переднего плана или фона) окрасить текущий пиксель.

```c++
// ПРИМЕР №1: Рисуем круг
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{    
    vec2 uv = fragCoord/iResolution.xy;

    // ПЕРЕМЕННЫЕ    
    // цвет переднего плана
    vec3 fg_color = vec3(1,1,1);
    // цвет фона
    vec3 bg_color = vec3(0,0,0);
    // радиус круга
    float radius = 0.3;
    
    // вычисляем расстояние текущего фрагмента от центра
    // по формуле Пифагора (суть это длина радиус-вектора)
    float dist = sqrt(uv.x*uv.x* + uv.y*uv.y);
    
    // сравниваем с желаемым радусом и заполняем цветом фронта или фона
    if (dist < radius)
        fragColor = vec4(fg_color, 1.0);
    else
        fragColor = vec4(bg_color, 1.0);    
}
```

Однако результат может вас удивить: вместо круга мы увидим лишь его четверть — сектор, лежащий в левом нижнем углу. Объяснется это тем, что начало отсчета экранных координат с координатами (0,0) лежит именно в левом нижем углу, тогда как противолежащий ему правый верхний угол экрана имеет координаты (1,1) в нормализованном виде.

> ПРИМЕЧАНИЕ: Начало отсчета UV координат в **OpenGL** лежит в **левом нижнем** углу, а в **DirectX** – в **левом верхнем**.

Чтобы нарисовать круг в центре вьюпорта, нам необходимо сместить начало отсчета в центр вьюпорта, добавим смещение координат на половину "экрана". Т.к. uv – являются нормализованными координатами фрагмента, т.е. лежат в диапазоне от 0 до 1, то нам нужно добавить смещение 0.5. Однако, обратите внимание, что смещение в данном случае будет отрицательным (т.к. значения лежат в [0,1]?).

## Круг или эллипс?

Итак мы сумели нарисовать круг из центра вьюпорта, или нет? В нашей ситуации визуально это эллипс, но никак не круг. Если у вас есть возможность изменить размер окна вьюпорта, то вы заметите, что круг становится кругом только тогда, когда вьюпорт принимает квадратную форму, т.е. когда пропорции его сторон составляют 1:1. Искажение круга происходит из-за того, что мы используем нормализованные координаты для его рисования, т.е. когда вьюпорт перестает быть идеальным квадратом, то нарушаются и пропорции выводимых в нем изображения. Например, для вьюпорта с разрешением в 500 пкс. по ширине и 250 пкс. по высоте, "единица" длины по ширине становится в 2 раза больше, чем по высоте, и как результат мы получаем эллипс – т.е. круг вытягивается по ширине согласно пропорции 2:1.

Все это наводит нас на мысль, что необходимо скорректировать координаты пикселя перед выводом его на экран, опираясь на текущие пропорции вьюпорта. Но какую из размерностей мы будем изменять: ширину или высоту?.. Или может быть сразу оба значения? На самом деле нам стоит рассмотреть следующие три ситуации:

- вьюпорт — идеальный квадрат, т.е. пропорции сторон 1:1;

- вьюпорт – прямоугольник в landscape/desktop ориентации, т.е. с бОльшей **шириной**, например, 4:3 или 16:9;

- вьюпорт – прямоугольник в portrait/"mobile" ориентации, т.е. с бОльшей **высотой**, например, 9:16.

Первый случай мы оставляем без внимания, т.к. на деле он будет "поглощен" одним из двух следующих.

### Случай Landscape/desktop ориентации

Когда экран(=вьюпорт) имеет бОльшую *ширину*, то имеет смысл "вмещать", подгонять содержимое по высоте: здесь `y` координату мы оствляем без изменений, а `x` корректируем на коэффициент, показывающий во сколько раз ширина отличается от высоты:

```c++
// landscape correction
uv.x *= iResolution.x/iResolution.y;
```

### Случай Portrait/Mobile ориентации

Когда экран имеет бОльшую *высоту*, то мы подгоняем содержимое во ширине: координата `x` остается без изменений, а `y` домножается на коэффициент, показывающий во сколько раз высота отличается от ширины.

```c++
// landscape correction
uv.y *= iResolution.y/iResolution.x;
```

### Универсальное решение

Объединив оба случая в блок проверки `if...else`, мы заставим код автоматически проверять текущие пропорции вьюпорта и корректировать их соотвествующим образом. Это дает возможность свободно изменять разрешение вьюпорта - корррекция будет происходить налету.

```c++
// Aspect Ratio Fix
// for Landscape mode
if(iResolution.x > iResolution.y)
    uv.x *=  (iResolution.x/iResolution.y);
// for Portrait mode
else if (iResolution.y > iResolution.x)
    uv.y *=  (iResolution.y/iResolution.x);
```

> Случай 1:1 можно было бы оставить на упрощенный `else` блок (отказавшись от `else if`), но так мы отбрасываем лишнюю операцию при "квадратном" вьюпорте (который, к слову, встречается не так часто). Плюс здесь в учебных целях хорошо просматриваются условия и их связь с необходимой коррекцией для обоих случаев.
